<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="tK~O-4`O27Jx@Jmv:my~" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="ZG7K^)2Q?e_,*6kgFn=6" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace rgbledring {" line1="" line2="    export enum PixelColors {" line3="        //% block=red" line4="        Red = 0xFF0000," line5="        //% block=orange" line6="        Orange = 0xFFA500," line7="        //% block=yellow" line8="        Yellow = 0xFFFF00," line9="        //% block=green" line10="        Green = 0x00FF00," line11="        //% block=blue" line12="        Blue = 0x0000FF," line13="        //% block=indigo" line14="        Indigo = 0x4b0082," line15="        //% block=violet" line16="        Violet = 0x8a2be2," line17="        //% block=purple" line18="        Purple = 0xFF00FF," line19="        //% block=white" line20="        White = 0xFFFFFF," line21="        //% block=black" line22="        Black = 0x000000" line23="    }" line24="" line25="    export enum Mode {" line26="        //% block=&quot;RGB (GRB format)&quot;" line27="        RGB = 0," line28="        //% block=&quot;RGB+W&quot;" line29="        RGBW = 1," line30="        //% block=&quot;RGB (RGB format)&quot;" line31="        RGB_RGB = 2" line32="    }" line33="" line34="" line35="        let _buf: Buffer;" line36="        let _pin: DigitalPin;        " line37="        let _brightness: number;" line38="        let _start: number; // start offset in board" line39="        let _length: number; // number of LEDs" line40="        let _mode: Mode;" line41="     " line42="        //% blockId=&quot;setbrightness&quot; block=&quot;Set brightness %brightness&quot;" line43="        //% brightness.defl=255 brightness.min=0 brightness.max=255" line44="        export function setBrightness(brightness: number): void {" line45="            _brightness = brightness &amp; 0xff;" line46="        }" line47="         " line48="        /**" line49="        * Converts red, green, blue channels into a RGB color" line50="        * @param red value of the red channel between 0 and 255. eg: 255" line51="        * @param green value of the green channel between 0 and 255. eg: 255" line52="        * @param blue value of the blue channel between 0 and 255. eg: 255" line53="        */" line54="        //% blockId=&quot;rgb&quot; block=&quot;red %red|green %green|blue %blue&quot;" line55="        export function rgb(red: number, green: number, blue: number): number {" line56="            return packRGB(red, green, blue);" line57="        }" line58=" " line59="        /**" line60="        * Gets the RGB value of a known color" line61="        */" line62="        //% blockId=&quot;inColors&quot; block=&quot;%color&quot;" line63="        export function inColors(color: PixelColors): number {" line64="            return color;" line65="        }" line66="" line67="        /**" line68="        * Shows all LEDs to a given color (range 0-255 for r, g, b). " line69="        * @param rgb RGB color of the LED" line70="        */" line71="        //% blockId=&quot;showColor&quot; block=&quot;Show color rgb=%rgbValue pixel_colors&quot; " line72="        export function showColor(rgbValue: number) {" line73="            rgbValue = rgbValue &gt;&gt; 0;" line74="            setAllRGB(rgbValue);" line75="            show();" line76="        }" line77="" line78="        //% blockId=&quot;clear&quot; block=&quot;clear&quot;" line79="        export function clear(): void {" line80="            const stride = _mode === Mode.RGBW ? 4 : 3;" line81="            _buf.fill(0, _start * stride, _length * stride);" line82="            show()" line83="        }" line84="" line85="        //% blockId=&quot;show&quot; block=&quot;Show&quot;" line86="        export function show() {" line87="            ws2812b.sendBuffer(_buf, _pin);" line88="        }" line89="" line90="        //% blockId=&quot;setPixelColor&quot; block=&quot;Set pixel color at %offset|to %crgb&quot; " line91="        //% offset.min=1" line92="        export function setPixelColor(offset: number, crgb: number): void {" line93="            if( offset &gt; 0 )" line94="                offset -= 1" line95="            setPixelRGB(offset &gt;&gt; 0, crgb &gt;&gt; 0);" line96="        }" line97="    " line98="        //% blockId=&quot;showRainbow&quot; block=&quot;Show rainbow from %startHue|to %endHue&quot; " line99="        //% startHue.defl=1" line100="        //% endHue.defl=360" line101="        export function showRainbow(startHue: number = 1, endHue: number = 360) {" line102="            if (_length &lt;= 0) return;" line103="" line104="            startHue = startHue &gt;&gt; 0;" line105="            endHue = endHue &gt;&gt; 0;" line106="            const saturation = 100;" line107="            const luminance = 50;" line108="            const steps = _length;" line109="            const direction = HueInterpolationDirection.Clockwise;" line110="" line111="            //hue" line112="            const h1 = startHue;" line113="            const h2 = endHue;" line114="            const hDistCW = ((h2 + 360) - h1) % 360;" line115="            const hStepCW = Math.idiv((hDistCW * 100), steps);" line116="            const hDistCCW = ((h1 + 360) - h2) % 360;" line117="            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);" line118="            let hStep: number;" line119="            if (direction === HueInterpolationDirection.Clockwise) {" line120="                hStep = hStepCW;" line121="            } else if (direction === HueInterpolationDirection.CounterClockwise) {" line122="                hStep = hStepCCW;" line123="            } else {" line124="                hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;" line125="            }" line126="            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation" line127="" line128="            //sat" line129="            const s1 = saturation;" line130="            const s2 = saturation;" line131="            const sDist = s2 - s1;" line132="            const sStep = Math.idiv(sDist, steps);" line133="            const s1_100 = s1 * 100;" line134="" line135="            //lum" line136="            const l1 = luminance;" line137="            const l2 = luminance;" line138="            const lDist = l2 - l1;" line139="            const lStep = Math.idiv(lDist, steps);" line140="            const l1_100 = l1 * 100" line141="" line142="            //interpolate" line143="            if (steps === 1) {" line144="                setPixelColor(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))" line145="            } else {" line146="                setPixelColor(0, hsl(startHue, saturation, luminance));" line147="                for (let i = 1; i &lt; steps - 1; i++) {" line148="                    const h = Math.idiv((h1_100 + i * hStep), 100) + 360;" line149="                    const s = Math.idiv((s1_100 + i * sStep), 100);" line150="                    const l = Math.idiv((l1_100 + i * lStep), 100);" line151="                    setPixelColor(i, hsl(h, s, l));" line152="                }" line153="                setPixelColor(steps - 1, hsl(endHue, saturation, luminance));" line154="            }" line155="            show();" line156="        }" line157="    " line158="        //% blockId=&quot;initLEDRing&quot; block=&quot;Set RGB LED Ring at pin %pin|with %numleds|leds as %mode&quot;" line159="        export function initLEDRing(pin: DigitalPin, numleds: number, mode: Mode) {" line160="            _pin = pin" line161="            _start = 0" line162="            _length = numleds" line163="            let stride2 = mode === Mode.RGBW ? 4 : 3;" line164="            _mode = mode" line165="            _brightness = 128" line166="            _buf = pins.createBuffer(numleds * stride2);" line167="        }" line168="        " line169="        function setPixelWhiteLED(pixeloffset: number, white: number): void {            " line170="            if (_mode === Mode.RGBW) {" line171="                setPixelW(pixeloffset &gt;&gt; 0, white &gt;&gt; 0);" line172="            }" line173="        }" line174="" line175="        function length() {" line176="            return _length;" line177="        }" line178="" line179="        function easeBrightness(): void {" line180="            const stride22 = _mode === Mode.RGBW ? 4 : 3;" line181="            const br = _brightness;" line182="            const buf = _buf;" line183="            const end = _start + _length;" line184="            const mid = Math.idiv(_length, 2);" line185="            for (let j = _start; j &lt; end; ++j) {" line186="                const k = j - _start;" line187="                const ledoffset = j * stride22;" line188="                const br2 = k &gt; mid" line189="                    ? Math.idiv(255 * (_length - 1 - k) * (_length - 1 - k), (mid * mid))" line190="                    : Math.idiv(255 * k * k, (mid * mid));" line191="                const r = (buf[ledoffset + 0] * br2) &gt;&gt; 8; buf[ledoffset + 0] = r;" line192="                const g = (buf[ledoffset + 1] * br2) &gt;&gt; 8; buf[ledoffset + 1] = g;" line193="                const b = (buf[ledoffset + 2] * br2) &gt;&gt; 8; buf[ledoffset + 2] = b;" line194="                if (stride22 == 4) {" line195="                    const w = (buf[ledoffset + 3] * br2) &gt;&gt; 8; buf[ledoffset + 3] = w;" line196="                }" line197="            }" line198="        }" line199="" line200="        function setPin(pin: DigitalPin): void {" line201="            _pin = pin;" line202="            pins.digitalWritePin(_pin, 0);" line203="            // don't yield to avoid races on initialization" line204="        }" line205="" line206="        function power(): number {" line207="            const stride3 = _mode === Mode.RGBW ? 4 : 3;" line208="            const end2 = _start + _length;" line209="            let p = 0;" line210="            for (let m = _start; m &lt; end2; ++m) {" line211="                const ledoffset2 = m * stride3;" line212="                for (let n = 0; n &lt; stride3; ++n) {" line213="                    p += _buf[m + n];" line214="                }" line215="            }" line216="            return Math.idiv(length(), 2) /* 0.5mA per neopixel */" line217="                + Math.idiv(p * 433, 10000); /* rought approximation */" line218="        }" line219="" line220="        function setBufferRGB(offset: number, red: number, green: number, blue: number): void {" line221="            if (_mode === Mode.RGB_RGB) {" line222="                _buf[offset + 0] = red;" line223="                _buf[offset + 1] = green;" line224="            } else {" line225="                _buf[offset + 0] = green;" line226="                _buf[offset + 1] = red;" line227="            }" line228="            _buf[offset + 2] = blue;" line229="        }" line230="" line231="        function setAllRGB(rgb: number) {" line232="            let red = unpackR(rgb);" line233="            let green = unpackG(rgb);" line234="            let blue = unpackB(rgb);" line235="" line236="            const br3 = _brightness;" line237="            if (br3 &lt; 255) {" line238="                red = (red * br3) &gt;&gt; 8;" line239="                green = (green * br3) &gt;&gt; 8;" line240="                blue = (blue * br3) &gt;&gt; 8;" line241="            }" line242="            const end3 = _start + _length;" line243="            const stride4 = _mode === Mode.RGBW ? 4 : 3;" line244="            for (let o = _start; o &lt; end3; ++o) {" line245="                setBufferRGB(o * stride4, red, green, blue)" line246="            }" line247="        }" line248="        function setAllW(white: number) {" line249="            if (_mode !== Mode.RGBW)" line250="                return;" line251="" line252="            let br4 = _brightness;" line253="            if (br4 &lt; 255) {" line254="                white = (white * br4) &gt;&gt; 8;" line255="            }" line256="            let buf2 = _buf;" line257="            let end4 = _start + _length;" line258="            for (let q = _start; q &lt; end4; ++q) {" line259="                let ledoffset3 = q * 4;" line260="                buf2[ledoffset3 + 3] = white;" line261="            }" line262="        }" line263="        function setPixelRGB(pixeloffset: number, rgb: number): void {" line264="            if (pixeloffset &lt; 0" line265="                || pixeloffset &gt;= _length)" line266="                return;" line267="" line268="            let stride5 = _mode === Mode.RGBW ? 4 : 3;" line269="            pixeloffset = (pixeloffset + _start) * stride5;" line270="" line271="            let red2 = unpackR(rgb);" line272="            let green2 = unpackG(rgb);" line273="            let blue2 = unpackB(rgb);" line274="" line275="            let br5 = _brightness;" line276="            if (br5 &lt; 255) {" line277="                red2 = (red2 * br5) &gt;&gt; 8;" line278="                green2 = (green2 * br5) &gt;&gt; 8;" line279="                blue2 = (blue2 * br5) &gt;&gt; 8;" line280="            }" line281="            setBufferRGB(pixeloffset, red2, green2, blue2)" line282="        }" line283="        function setPixelW(pixeloffset: number, white: number): void {" line284="            if (_mode !== Mode.RGBW)" line285="                return;" line286="" line287="            if (pixeloffset &lt; 0" line288="                || pixeloffset &gt;= _length)" line289="                return;" line290="" line291="            pixeloffset = (pixeloffset + _start) * 4;" line292="" line293="            let br6 = _brightness;" line294="            if (br6 &lt; 255) {" line295="                white = (white * br6) &gt;&gt; 8;" line296="            }" line297="            let buf3 = _buf;" line298="            buf3[pixeloffset + 3] = white;" line299="        }" line300="    " line301="" line302="    function packRGB(a: number, b: number, c: number): number {" line303="        return ((a &amp; 0xFF) &lt;&lt; 16) | ((b &amp; 0xFF) &lt;&lt; 8) | (c &amp; 0xFF);" line304="    }" line305="    function unpackR(rgb: number): number {" line306="        let t = (rgb &gt;&gt; 16) &amp; 0xFF;" line307="        return t;" line308="    }" line309="    function unpackG(rgb: number): number {" line310="        let u = (rgb &gt;&gt; 8) &amp; 0xFF;" line311="        return u;" line312="    }" line313="    function unpackB(rgb: number): number {" line314="        let c = (rgb) &amp; 0xFF;" line315="        return c;" line316="    }" line317="" line318="    function hsl(h: number, s: number, l: number): number {" line319="        h = Math.round(h);" line320="        s = Math.round(s);" line321="        l = Math.round(l);" line322="        " line323="        h = h % 360;" line324="        s = Math.clamp(0, 99, s);" line325="        l = Math.clamp(0, 99, l);" line326="        let d = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]" line327="        let h12 = Math.idiv(h, 60);//[0,6]" line328="        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]" line329="        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);" line330="        let x = (d * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color" line331="        let r$: number;" line332="        let g$: number;" line333="        let b$: number;" line334="        if (h12 == 0) {" line335="            r$ = d; g$ = x; b$ = 0;" line336="        } else if (h12 == 1) {" line337="            r$ = x; g$ = d; b$ = 0;" line338="        } else if (h12 == 2) {" line339="            r$ = 0; g$ = d; b$ = x;" line340="        } else if (h12 == 3) {" line341="            r$ = 0; g$ = x; b$ = d;" line342="        } else if (h12 == 4) {" line343="            r$ = x; g$ = 0; b$ = d;" line344="        } else if (h12 == 5) {" line345="            r$ = d; g$ = 0; b$ = x;" line346="        }" line347="        let v = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - d), 2);" line348="        let a = r$ + v;" line349="        let e = g$ + v;" line350="        let f = b$ + v;" line351="        return packRGB(a, e, f);" line352="    }" line353="" line354="    export enum HueInterpolationDirection {" line355="        Clockwise," line356="        CounterClockwise," line357="        Shortest" line358="    }" line359="}" numlines="360"></mutation></block></statement></block></xml>